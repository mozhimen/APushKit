# MTPush-API

[TOC]

## MTCorePrivatesApi

> * 主要用于信息配置
> * **所有方法都需要在主进程中调用，请不要在方法调用前判断进程将其放到子进程，否则调用出错**


### <span id = "configAppKey">configAppKey</span>

> * 需要在Application.onCreate()方法中调用
> * 请在[init](#init)之前调用

```
    /**
     * 配置应用key，不使用AndroidManifest.xml中的配置
     *
     * 需要在Application.onCreate()方法中调用
     * 请在[init](#init)之前调用
     *
     * @param context 不为空
     * @param appKey 不为空
     */
    public static void configAppKey(Context context, String appKey)
```

代码示例如下

```
MTCorePrivatesApi.configAppKey(this,"你的appkey");
```


### <span id = "configAppSiteName">configAppSiteName</span>

> * 需要在Application.onCreate()方法中调用
> * 请在[init](#init)之前调用

```
    /**
     * 配置数据中心站点名称，不使用AndroidManifest.xml中的配置
     *
     * 需要在Application.onCreate()方法中调用
     * 请在[init](#init)之前调用
     *
     * @param context 不为空
     * @param appSiteName 不为空
     */
    public static void configAppSiteName(Context context, String appSiteName)
```

代码示例如下

```
MTCorePrivatesApi.configAppSiteName(this,"你的平台数据中心站点名称");
```


### <span id = "configHeartbeatInterval">configHeartbeatInterval</span>

> * 需要在Application.onCreate()方法中调用
> * 请在[init](#init)之前调用

```
    /**
     * 设置心跳时间间隔
     *
     * 需要在Application.onCreate()方法中调用
     *
     * @param context 不为空
     * @param heartbeatInterval 时间单位为毫秒、必须大于0、默认值是4分50秒\
     */
    public static void configHeartbeatInterval(Context context, long heartbeatInterval)
```

代码示例如下

> * 演示设置心跳时间间隔为3分钟

```
MTCorePrivatesApi.configHeartbeatInterval(this,3 * 60 * 1000);
```

### <span id = "configConnectRetryCount">configConnectRetryCount</span>

> * 需要在Application.onCreate()方法中调用
> * 请在[init](#init)之前调用

```
    /**
     * 设置长连接重试次数
     *
     * 需要在Application.onCreate()方法中调用
     *
     * @param context 不为空
     * @param connectRetryCount 重试的次数、默认值为3、最少3次
     */
    public static void configConnectRetryCount(Context context, int connectRetryCount)
```

代码示例如下

> *演示设置重连次数为10次

```
MTCorePrivatesApi.configConnectRetryCount(this,10);
```
### <span id = "setTcpSSl">setTcpSSl</span>

> * 需要在Application.onCreate()方法中调用
> * 请在[init](#init)之前调用

```
    /**
     * 设置长连接是否加密，默认不加密
     *
     * 需要在Application.onCreate()方法中调用
     *
     * @param isSSL true加密，false不加密
     */
    public static void setTcpSSl(Context context, boolean isSSL)
```

代码示例如下

> *演示设置加密

```
MTCorePrivatesApi.setTcpSSl(context,true);
```

### configDebugMode

> * 需要在Application.onCreate()方法中调用
>* 请在[init](#init)之前调用
> * Engagelab日志格式，搜索"ENGAGELAB-PRIVATES"
>* Engagelab会分别在主进程和子进程打印日志

```
    /**
     * 设置是否debug模式，debug模式会打印更对详细日志
     *
     * 需要在Application.onCreate()方法中调用
     * 
     * @param context 不为空 
     * @param enable 是否调试模式，true为调试模式，false不是
     */
    public static void configDebugMode(Context context, boolean enable)
```

代码示例如下

>* sdk在两个进程工作，主进程和子进程，子进程名为MTCommonService子类service的process属性名
>* sdk的日志tag为"ENGAGELAB-PRIVATES"
>* udp/tcp/http相关操作的日志均在子进程
>* 所以遇到消息无法推送的情况，请先打开调试模式，再前往子进程获取tag为"ENGAGELAB-PRIVATES"的日志，提供给技术支持分析

```
		// 建议应用未上线时设置为true，方便集成
		MTCorePrivatesApi.configDebugMode(context.getApplicationContext(), true);
		
		// 建议应用上线后设置为false
		MTCorePrivatesApi.configDebugMode(context.getApplicationContext(), false);
```

### configSM4

> * 需要在Application.onCreate()方法中调用
> * 请在[init](#init)之前调用

```
    /**
     * 配置使用国密加密
     *
     * @param context 不为空
     */
    public static void configSM4(Context context)
```

示例代码如下

```
    // 开启国密加密，不调用则使用默认加密方式
    MTCorePrivatesApi.configSM4(context.getApplicationContext());
```

### <span id = "getUserId">getUserId</span>

> 返回值为空时需要注意是否配置了环境，是否调用了初始化
>
> 如果检查配置无误，可能还在连接过程中，可在[onConnectStatus](#onConnectStatus)返回true时再获取

```
    /**
     * 获取当前设备的userId，Engagelab唯一标识，可同于推送
     *
     * @param context 不为空
     * @return userId
     */
    public static String getUserId(Context context)
```

代码示例如下

```
String userId = MTCorePrivatesApi.getUserId(context);
```

### <span id = "getRegistrationId">getRegistrationId</span>

> 返回值为空时需要注意是否配置了环境，是否调用了初始化
>
> 如果检查配置无误，可能还在连接过程中，可在[onConnectStatus](#onConnectStatus)返回true时再获取

```
    /**
     * 获取当前设备的registrationId，Engagelab唯一标识，可同于推送
     *
     * @param context 不为空
     * @return registrationId
     */
    public static String getRegistrationId(Context context)
```

代码示例如下

```
String registrationId = MTCorePrivatesApi.getRegistrationId(context);
```

## MTPushPrivatesApi

> * 主要用于推送功能
> * **所有方法都需要在主进程中调用，请不要在方法调用前判断进程将其放到子进程，否则调用出错**

### <span id = "configOldPushVersion">configOldPushVersion</span>

> * 后台没升级`tag: V3.5.4-newportal-20210823-gamma.57`版本，前端必须调用此方法，否则通知点击跳转有问题
> * 在Application.onCreate()方法中调用
> * 请在[init](#init)前调用

```
    /**
     * 配置push版本号为3.9.X
     *
     * @param context 不为空
     */
    public static void configOldPushVersion(Context context)
```

代码示例如下：

```
public class ExampleApplication extends Application {

    @Override
    public void onCreate() {
        // 打开调试模式    
    	MTCorePrivatesApi.configDebugMode(context.getApplicationContext(), true);
    	// 使用老版本的通知点击跳转
    	MTPushPrivatesApi.configOldPushVersion(context.getApplicationContext());
    	// 初始化
        MTPushPrivatesApi.init(context.getApplicationContext());   
    }
}
```


### <span id = "configUserLanguage">configUserLanguage</span>


```
    /**
     * 配置push通知语言，在MTPushPrivatesApi.init后使用
     *
     * @param context      不为空
     * @param pushLanguage 为空字符串时，恢复使用手机语言
     */
    public static void configUserLanguage(Context context, String pushLanguage)
```

代码示例如下：

```
    MTPushPrivatesApi.configUserLanguage(context,"zh_CN");   
```

### <span id = "setEnablePushTextToSpeech">setEnablePushTextToSpeech</span>


```
    /**
     * 语音播报功能设置,需要导入语音包(mt-sdk-sound-x.x.x.aar)
     *
     * @param context      不为空
     * @param enable true为打开，false为关闭，默认为false
     */
    public static void setEnablePushTextToSpeech(Context context, boolean enable)
```

代码示例如下：

```
    MTPushPrivatesApi.setEnablePushTextToSpeech(context,true);   
```


### <span id = "init">init</span>
> * 建议在Application.onCreate()方法中调用

```
    /**
     * MTPush初始化
     *
     * 建议在Application.onCreate()方法中调用
     * 
     * @param context 不为空，请使用applicationContext对象
     */
    public static void init(Context context)
```

代码示例如下

```
public class ExampleApplication extends Application {

    @Override
    public void onCreate() {
        // 打开调试模式    
    	MTCorePrivatesApi.configDebugMode(context.getApplicationContext(), true);
    	// 初始化
        MTPushPrivatesApi.init(context.getApplicationContext());   
    }
}
```

### <span id = "goToAppNotificationSettings">goToAppNotificationSettings</span>

> * 启动sdk后可根据[onNotificationStatus](#onNotificationStatus)回调结果，再决定是否需要调用此借口

```
    /**
     * 前往通知开关设置页面
     *
     * @param context 不为空
     */
    public static void goToAppNotificationSettings(Context context)
```

示例代码如下

```
    // 前往通知开关设置页面，需要客户手动打开通知开关
    MTPushPrivatesApi.goToAppNotificationSettings(this);
    
    // 继承MTCommonReceiver后，复写onNotificationStatus方法，获取通知开关状态，如果enable为true说明已经开启成功
    @Override
    public void onNotificationStatus(Context context, boolean enable) {
				if(enable){
						// 已设置通知开关为打开
				}	    
    }
```

### <span id = "turnOnPush">turnOnPush</span>

> * 一般用于在调用[turnOffPush](#turnOffPush)后，需要再开启 push 推送
> * 重复调用只会生效一次，如果已经是开启状态，不会再生效
> * 如果环境没有问题，[onConnectStatus](#onConnectStatus)会回调结果
> * 目前支持的通道：Engagelab/华为/小米/魅族/oppo/vivo

```
    /**
     * 开启 Push 推送，并持久化存储开关状态为true，默认是true
     * 
     * @param context 不能为空
     */
    public static void turnOnPush(Context context)
```

代码示例如下

```
// 开启推送，默认就是打开的
MTPushPrivatesApi.turnOnPush(context);
		
// 继承MTCommonReceiver后，复写onConnectStatus方法，获取长连接的连接状态，如果enable为true说明已经开启成功
@Override
public void onConnectStatus(Context context, boolean enable){
    if(enable){
        // 开启 push 推送成功
    }				
}				
```

### <span id = "turnOffPush">turnOffPush</span>

> * 一般用于关闭 push 推送
> * 关闭 push 推送后，再调用init不会打开推送
> * 重复调用只会生效一次
> * 如果环境没有问题，[onConnectStatus](#onConnectStatus)会回调结果
> * 目前支持的通道：Engagelab/华为/小米/魅族/oppo/vivo

```
    /**
     * 关闭 push 推送，并持久化存储开关状态为false，默认是true
     *
     * @param context 不能为空
     */
    public static void turnOffPush(Context context)
```

代码示例如下

```
// 关闭推送，需要再调用turnOnPush才能开启推送
MTPushPrivatesApi.turnOffPush(context);
		
// 继承MTCommonReceiver后，复写onConnectStatus方法，获取长连接状态，如果enable为false说明已经关闭成功
@Override
public void onConnectStatus(Context context, boolean enable){
    if(!enable){
        // 关闭 push 推送成功
    }
}		
```

### <span id = "addTag">addTag</span>

> * 请先[init](#init)，否则调用无效
> * 如果环境没有问题，[onTagMessage](#onTagMessage)会回调结果

```
    /**
     * 增加指定tag，累加逻辑，之前设置的标签依然存在
     *
     * @param context  不能为空
     * @param sequence 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性
     * @param tags     标签数组，每个tag命名长度限制为40字节，最多支持设置1000个tag，且单次操作总长度不得超过5000字节
     */
    public static void addTag(Context context, int sequence, String... tags)
```

代码示例如下

```
		// 这里定义一个常量，代表增加指定tag操作
		private static final int SEQUENCE_TAG_ADD = 1;
		// 增加tag:"china","guangdong","shenzhen"
		MTPushPrivatesApi.addTag(context,SEQUENCE_TAG_ADD,"china","guangdong","shenzhen")
			
		// 继承MTCommonReceiver后，复写onTagMessage方法，获取tag操作回调
		@Override
		public void onTagMessage(Context context, TagMessage tagMessage){
				if(tagMessage.getCode != MTPushPrivatesApi.Code.Success){
						// tag操作失败，详细错误信息可查看MTPushPrivatesApi.Code
						return;
				}
				if(tagMessage.getSequence() == SEQUENCE_TAG_ADD){
						// 增加指定tag成功，此时可查看操作成功的tag数组
						String[] tags = tagMessage.getTags();
				}
		}
```

### <span id = "deleteTag">deleteTag</span>

> * 请先[init](#init)，否则调用无效
> * 如果环境没有问题，[onTagMessage](#onTagMessage)会回调结果

```
    /**
     * 删除指定tag，删除逻辑，会删除指定的标签
     *
     * @param context  不能为空
     * @param sequence 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性
     * @param tags     标签数组，每个tag命名长度限制为40字节，最多支持设置1000个tag，且单次操作总长度不得超过5000字节
     */
    public static void deleteTag(Context context, int sequence, String... tags)
```

代码示例如下：

		// 这里定义一个常量，代表删除指定tag操作
		private static final int SEQUENCE_TAG_DELETE = 2;
		// 删除tag:"china","guangdong","shenzhen"
		MTPushPrivatesApi.deleteTag(context,SEQUENCE_TAG_DELETE,"china","guangdong","shenzhen")
		
		// 继承MTCommonReceiver后，复写onTagMessage方法，获取tag操作回调
		@Override
		public void onTagMessage(Context context, TagMessage tagMessage){
				if(tagMessage.getCode != MTPushPrivatesApi.Code.Success){
						// tag操作失败，详细错误信息可查看MTPushPrivatesApi.Code
						return;
				}
				if(tagMessage.getSequence() == SEQUENCE_TAG_DELETE){
						// 删除指定tag成功，此时可查看操作成功的tag数组
						String[] tags = tagMessage.getTags();
				}
		}

### <span id = "updateTag">updateTag</span>

> * 请先[init](#init)，否则调用无效
> * 如果环境没有问题，[onTagMessage](#onTagMessage)会回调结果

```
    /**
     * 更新指定tag，覆盖逻辑，之前添加的tag会清空
     *
     * @param context  不能为空
     * @param sequence 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性
     * @param tags     标签数组，每个tag命名长度限制为40字节，最多支持设置1000个tag，且单次操作总长度不得超过5000字节
     */
    public static void updateTag(Context context, int sequence, String... tags)
```

代码示例如下：

		// 这里定义一个常量，代表更新指定tag操作
		private static final int SEQUENCE_TAG_UPDATE = 3;
		// 更新tag:"beijing","shanghai","guangzhou","shenzhen"，之前设置的tag会失效
		MTPushPrivatesApi.updateTag(context,SEQUENCE_TAG_UPDATE,"beijing","shanghai","guangzhou","shenzhen")
		
		// 继承MTCommonReceiver后，复写onTagMessage方法，获取tag操作回调
		@Override
		public void onTagMessage(Context context, TagMessage tagMessage){
				if(tagMessage.getCode != MTPushPrivatesApi.Code.Success){
						// tag操作失败，详细错误信息可查看MTPushPrivatesApi.Code
						return;
				}
				if(tagMessage.getSequence() == SEQUENCE_TAG_UPDATE){
						// 更新指定tag成功，此时可查看操作成功的tag数组
						String[] tags = tagMessage.getTags();
				}
		}

### <span id = "queryTag">queryTag</span>

> * 请先[init](#init)，否则调用无效
> * 如果环境没有问题，[onTagMessage](#onTagMessage)会回调结果

```
    /**
     * 查询指定tag
     * 
     * @param context  不能为空
     * @param sequence 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性
     * @param tag      标签，每个tag命名长度限制为40字节
     */
    public static void queryTag(Context context, int sequence, String tag)
```

代码示例如下

```
	// 这里定义一个常量，代表查询指定tag操作
	private static final int SEQUENCE_TAG_QUERY = 4;
	// 查询标签
	MTPushPrivatesApi.queryTag(context,SEQUENCE_TAG_QUERY,"china")
	
	// 继承MTCommonReceiver后，复写onTagMessage方法，获取tag操作回调
	@Override
	public void onTagMessage(Context context, TagMessage tagMessage){
			if(tagMessage.getCode != MTPushPrivatesApi.Code.Success){
					// tag操作失败，详细错误信息可查看MTPushPrivatesApi.Code
					return;
			}
			if(tagMessage.getSequence() == SEQUENCE_TAG_QUERY){
					// 查询指定tag成功，此时可查看操作成功的tag和状态
					String tag = 	tagMessage.getQueryTag();
					boolean valid = tagMessage.isQueryTagValid();
			}
	}	
```

### <span id = "deleteAllTag">deleteAllTag</span>

> * 请先[init](#init)，否则调用无效
> * 如果环境没有问题，[onTagMessage](#onTagMessage)会回调结果

```
    /**
     * 删除所有tag，清空逻辑，会删除所有的标签
     *
     * @param context  不能为空
     * @param sequence 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性
     */
    public static void deleteAllTag(Context context, int sequence, String... tags)
```

代码示例如下：

		// 这里定义一个常量，代表删除所有tag操作
		private static final int SEQUENCE_TAG_DELETE_ALL = 5;
		// 删除所有tag
		MTPushPrivatesApi.deleteTag(context,SEQUENCE_TAG_DELETE_ALL)
		
		// 继承MTCommonReceiver后，复写onTagMessage方法，获取tag操作回调
		@Override
		public void onTagMessage(Context context, TagMessage tagMessage){
				if(tagMessage.getCode != MTPushPrivatesApi.Code.Success){
						// tag操作失败，详细错误信息可查看MTPushPrivatesApi.Code
						return;
				}
				if(tagMessage.getSequence() == SEQUENCE_TAG_DELETE_ALL){
						// 删除所有tag成功
				}
		}

### <span id = "queryAllTag">queryAllTag</span>

> * 请先[init](#init)，否则调用无效
> * 如果环境没有问题，[onTagMessage](#onTagMessage)会回调结果

```
    /**
     * 查询所有tag，获取逻辑，会获取所有标签
     *
     * @param context  不能为空
     * @param sequence 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性
     */
    public static void queryAllTag(Context context, int sequence, String... tags)
```

代码示例如下：

		// 这里定义一个常量，代表查询所有tag操作
		private static final int SEQUENCE_TAG_QUERY_ALL = 6;
		// 查询所有tag
		MTPushPrivatesApi.queryAllTag(context,SEQUENCE_TAG_QUERY_ALL)
		
		// 继承MTCommonReceiver后，复写onTagMessage方法，获取tag操作回调
		@Override
		public void onTagMessage(Context context, TagMessage tagMessage){
				if(tagMessage.getCode != MTPushPrivatesApi.Code.Success){
						// tag 操作失败，详细错误信息可查看MTPushPrivatesApi.Code
						return;
				}
				if(tagMessage.getSequence() == SEQUENCE_TAG_DELETE_ALL){
						// 查询所有tag成功，此时可查看操作成功的tag数组
						String[] tags = tagMessage.getTags();
				}
		}

### <span id = "setAlias">setAlias</span>

> * 请先[init](#init)，否则调用无效
> * 如果环境没有问题，[onAliasMessage](#onAliasMessage)会回调结果

```
    /**
     * 设置alias
     * 
     * 同一个应用程序内，对不同的用户，建议取不同的别名。这样，尽可能根据别名来唯一确定用户
     * 
     * 不限定一个别名只能指定一个用户
     *
     * @param context  不能为空
     * @param sequence 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性
     * @param alias    有效的别名组成：字母（区分大小写）、数字、下划线、汉字、特殊字符@!#$&*+=.|。限制：alias命名长度限制为 40 字节（判断长度需采用 UTF-8 编码）
     *                             
     */
    public static void setAlias(Context context, int sequence, String alias) 
```

 示例代码如下

```
	// 这里定义一个常量，代表设置alias操作
	private static final int SEQUENCE_ALIAS_SET = 7;
	// 设置alias:"young"
	MTPushPrivatesApi.setAlias(context,SEQUENCE_ALIAS_SET,"young")
	
	// 继承MTCommonReceiver后，复写onAliasMessage方法，获取alias操作回调
	@Override
	public void onAliasMessage(Context context, AliasMessage aliasMessage){
			if(aliasMessage.getCode != MTPushPrivatesApi.Code.Success){
					// alias操作失败，详细错误信息可查看MTPushPrivatesApi.Code
					return;
			}
			if(aliasMessage.getSequence() == SEQUENCE_ALIAS_SET){
					// 设置alias成功，此时可查看操作成功的alias
					String alias = 	aliasMessage.getAlias();
			}
	}	
```

### <span id = "getAlias">getAlias</span>

> * 请先[init](#init)，否则调用无效
> * 如果环境没有问题，[onAliasMessage](#onAliasMessage)会回调结果

```
    /**
     * 获取alias
     * 
     * 同一个应用程序内，对不同的用户，建议取不同的别名。这样，尽可能根据别名来唯一确定用户
     * 
     * 不限定一个别名只能指定一个用户
     *
     * @param context  不能为空
     * @param sequence 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性
     */
    public static void getAlias(Context context, int sequence)
```

示例代码如下:

```
	// 这里定义一个常量，代表获取alias操作
	private static final int SEQUENCE_ALIAS_GET = 8;
	// 获取alias
	MTPushPrivatesApi.getAlias(context,SEQUENCE_ALIAS_GET)
	
	// 继承MTCommonReceiver后，复写onAliasMessage方法，获取alias操作回调
	@Override
	public void onAliasMessage(Context context, AliasMessage aliasMessage){
			if(aliasMessage.getCode != MTPushPrivatesApi.Code.Success){
					// alias 操作失败，详细错误信息可查看MTPushPrivatesApi.Code
					return;
			}
			if(aliasMessage.getSequence() == SEQUENCE_ALIAS_GET){
					// 获取alias成功，此时可查看操作成功的alias
					String alias = 	aliasMessage.getAlias();
			}
	}	
```

### <span id = "clearAlias">clearAlias</span>

> * 请先[init](#init)，否则调用无效
> * 如果环境没有问题，[onAliasMessage](#onAliasMessage)会回调结果

```
    /**
     * 清除alias
     *
     * 同一个应用程序内，对不同的用户，建议取不同的别名。这样，尽可能根据别名来唯一确定用户
     * 
     * 不限定一个别名只能指定一个用户
     *
     * @param context  不能为空
     * @param sequence 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性
     */
    public static void clearAlias(Context context, int sequence)
```

示例代码如下:

```
	// 这里定义一个常量，代表清除alias操作
	private static final int SEQUENCE_ALIAS_CLEAR = 7;
	// 清除alias
	MTPushPrivatesApi.clearAlias(context,SEQUENCE_ALIAS_CLEAR)
	
	// 继承MTCommonReceiver后，复写onAliasMessage方法，获取alias操作回调
	@Override
	public void onAliasMessage(Context context, AliasMessage aliasMessage){
			if(aliasMessage.getCode != MTPushPrivatesApi.Code.Success){
					// alias操作失败，详细错误信息可查看MTPushPrivatesApi.Code
					return;
			}
			if(aliasMessage.getSequence() == SEQUENCE_ALIAS_CLEAR){
					// 清除alias成功
			}
	}	
```

### <span id = "setNotificationShowTime">setNotificationShowTime</span>

> * 请先[init](#init)，否则调用无效
> * 目前支持的通道：Engagelab通道/应用在前台时的google通道（由Engagelab展示）

```
    /**
     * 设置通知展示时间，默认任何时间都展示
     *
     * @param context   不为空
     * @param beginHour 允许通知展示的开始时间（ 24 小时制，范围为 0 到 23 ）
     * @param endHour   允许通知展示的结束时间（ 24 小时制，范围为 0 到 23 ），beginHour不能大于等于endHour
     * @param weekDays  允许通知展示的星期数组（ 7 日制，范围为 1 到 7），空数组代表任何时候都不展示通知
     */
    public static void setNotificationShowTime(Context context, int beginHour, int endHour, int... weekDays)
```

示例代码如下

```
    // 设置通知展示时间为每周1/3/5/7的早上9点到晚上9点
    MTPushPrivatesApi.setNotificationShowTime(context, 9, 21, 1,3,5,7);
```

### <span id = "resetNotificationShowTime">resetNotificationShowTime</span>

> * 请先[init](#init)，否则调用无效
> * 目前支持的通道：Engagelab通道/应用在前台时的google通道（由Engagelab展示）

```
    /**
     * 重置通知展示时间，默认任何时间都展示
     *
     * @param context 不为空
     */
    public static void resetNotificationShowTime(Context context)
```

示例代码如下

```
    // 重置通知展示时间，默认任何时间都展示
    MTPushPrivatesApi.resetNotificationShowTime(context);
```

### <span id = "setNotificationSilenceTime">setNotificationSilenceTime</span>

> * 请先[init](#init)，否则调用无效
> * 目前支持的通道：Engagelab通道/应用在前台时的google通道（由Engagelab展示）

```
    /**
     * 设置通知静默时间，默认任何时间都不静默
     *
     * @param context     不为空
     * @param beginHour   允许通知静默的开始时间，单位小时（ 24 小时制，范围为 0 到 23 ）
     * @param beginMinute 允许通知静默的开始时间，单位分钟（ 60 分钟制，范围为 0 到 59 ）
     * @param endHour     允许通知静默的结束时间，单位小时（ 24 小时制，范围为 0 到 23 ）
     * @param endMinute   允许通知静默的结束时间，单位分钟（ 60 分钟制，范围为 0 到 59 ）
     */
    public static void setNotificationSilenceTime(Context context, int beginHour, int beginMinute, int endHour, int endMinute)
```

示例代码如下

```
    // 设置通知静默时间为每天晚上9点半到第二天早上9点半
    MTPushPrivatesApi.setNotificationSilenceTime(context, 21, 30, 9, 30);
```

### <span id = "resetNotificationSilenceTime">resetNotificationSilenceTime</span>

> * 请先[init](#init)，否则调用无效
> * 目前支持的通道：Engagelab通道/应用在前台时的google通道（由Engagelab展示）

```
    /**
     * 重置通知静默时间，默认任何时间都不静默
     *
     * @param context 不为空
     */
    public static void resetNotificationSilenceTime(Context context)
```

示例代码如下

```
    // 重置通知静默时间，默认任何时间都不静默
    MTPushPrivatesApi.resetNotificationSilenceTime(context);
```

### <span id = "setNotificationLayout">setNotificationLayout</span>

> * 请先[init](#init)，否则调用无效
> * 目前支持的通道：Engagelab通道

```
    /**
     * 设置自定义通知布局，默认使用系统通知布局
     *
     * @param context            不为空
     * @param builderId          构建id
     * @param notificationLayout 自定义通知布局的对象，不为空
     */
    public static void setNotificationLayout(Context context, int builderId, NotificationLayout notificationLayout)
```

示例代码如下

```
		// 这里定义一个常量，代表构建id
		private static final int BUILDER_ID = 11;
		
		// 构建出一个notificationLayout
    NotificationLayout notificationLayout = new NotificationLayout()
            .setLayoutId(R.layout.custom_notification_layout)        // 布局layout_id
            .setIconViewId(R.id.iv_notification_icon)                // 通知图标view_id
            .setIconResourceId(R.drawable.mtpush_notification_icon)   // 通知图标source_id
            .setTitleViewId(R.id.tv_notification_title)              // 通知标题view_id
            .setContentViewId(R.id.tv_notification_content)          // 通知内容view_id
            .setTimeViewId(R.id.tv_notification_time);               // 通知时间view_id
 
    // 设置构建id为BUILDER_ID的自定义布局，下发通知时指定builderId为BUILDER_ID，即可改变通知布局        
    MTPushPrivatesApi.setNotificationLayout(this.getApplicationContext(), BUILDER_ID, notificationLayout);
```

### <span id = "resetNotificationLayout">resetNotificationLayout</span>

> * 请先[init](#init)，否则调用无效
> * 目前支持的通道：Engagelab通道

```
    /**
     * 重置自定义通知布局，默认使用系统通知布局
     *
     * @param context   不为空
     * @param builderId 自定义通知布局的id
     */
    public static void resetNotificationLayout(Context context, int builderId)
```

示例代码如下

```
		// 这里定义一个常量，代表构建id
		private static final int BUILDER_ID = 11;
		
    // 重置构建id为BUILDER_ID的自定义布局，下发通知时指定builderId为BUILDER_ID，将使用系统默认布局
    MTPushPrivatesApi.resetNotificationLayout(context,BUILDER_ID);
```

### <span id = "setNotificationCount">setNotificationCount</span>

> * 请先[init](#init)，否则调用无效
> * 目前支持的通道：Engagelab通道/应用在前台时的google通道（由Engagelab展示）

```
    /**
     * 设置通知栏的通知数量，默认数量为5
     *
     * @param context 不为空
     * @param count   限制通知栏的通知数量，超出限制数量则移除最老通知，不能小于等于0
     */
    public static void setNotificationCount(Context context, int count)
```

示例代码如下

```
    // 设置通知栏通知数量为50
    MTPushPrivatesApi.setNotificationCount(context,50);
```

### <span id = "resetNotificationCount">resetNotificationCount</span>

> * 请先[init](#init)，否则调用无效
> * 目前支持的通道：Engagelab通道/应用在前台时的google通道（由Engagelab展示）

```
    /**
     * 重置通知栏的通知数量，默认数量为5
     *
     * @param context 不为空
     */
    public static void resetNotificationCount(Context context)
```

示例代码如下

```
    // 重置通知栏的通知数量，默认数量为5
    MTPushPrivatesApi.resetNotificationCount(context);
```

### <span id = "setNotificationBadge">setNotificationBadge</span>

> * 请先[init](#init)，否则调用无效

```
    /**
     * 设置应用角标数量，默认0（仅华为/荣耀生效）
     *
     * @param context 不为空
     * @param badge   应用角标数量
     */
    public static void setNotificationBadge(Context context, int badge)
```

示例代码如下

```
    // 设置应用角标数量为1
    MTPushPrivatesApi.setNotificationBadge(context,1);
```

### <span id = "resetNotificationBadge">resetNotificationBadge</span>

> * 请先[init](#init)，否则调用无效

```
    /**
     * 重置应用角标数量，默认0（仅华为/荣耀生效）
     *
     * @param context 不为空
     */
    public static void resetNotificationBadge(Context context) {
```

示例代码如下

```
    // 重置应用角标数量，默认0
    MTPushPrivatesApi.resetNotificationBadge(context);
```

### <span id = "showNotification">showNotification</span>

> * 请先[init](#init)，否则调用无效

```
    /**
     * 展示通知
     *
     * @param context             不为空
     * @param notificationMessage 构建的通知对象，不为空
     */
    public static void showNotification(Context context, NotificationMessage notificationMessage)
```

示例代码如下

```
    // 构建一个基础的通知，其中messageId和content是必须，否则通知无法展示
    NotificationMessage notificationMessage = new NotificationMessage()
            .setMessageId("12345")
            .setNotificationId(12345)
            .setTitle("custom_notification_title")
            .setContent("custom_notification_content");    
    // 展示通知
    MTPushPrivatesApi.showNotification(context,notificationMessage);
```

### <span id = "clearNotification">clearNotification</span>

> * 请先[init](#init)，否则调用无效

```
    /**
     * 清除指定notifyId的通知
     *
     * @param context  不为空
     * @param notifyId 通知id
     */
    public static void clearNotification(Context context, int notifyId)
```

示例代码如下

```
    // 清除指定notifyId的通知
    MTPushPrivatesApi.clearNotification(context,12345);
```

### <span id = "reportNotificationArrived">reportNotificationArrived</span>

> * 请先[init](#init)，否则调用无效
> * 不集成Engagelab的厂商包，但需要Engagelab统计通知送达率，请调用此接口

```
    /**
     * 上报厂商通道通知到达
     * 
     * 走http/https上报
     *
     * @param context           不为空
     * @param messageId         Engagelab消息id，不为空
     * @param platform          厂商，取值范围（1:mi、2:huawei、3:meizu、4:oppo、5:vivo、7:honor、8:google）
     * @param platformMessageId 厂商消息id，可为空
     */
    public static void reportNotificationArrived(Context context, String messageId, byte platform, String platformMessageId)
```

示例代码如下

```
    // 上报厂商通知到达，messageId为“12345”，厂商为小米，厂商messageId为“MI-6476RHT25”
    MTPushPrivatesApi.reportNotificationArrived(context,“12345”,MTPushPrivatesApi.PLATFORM_XIAOMI,"MI-6476RHT25");
```

### <span id = "reportNotificationClicked">reportNotificationClicked</span>

> * 请先[init](#init)，否则调用无效
> * 不集成Engagelab的厂商包，但需要Engagelab统计通知点击率，请调用此接口

```
    /**
     * 上报厂商通道通知点击
     * 
     * 走http/https上报
     *
     * @param context           不为空
     * @param messageId         Engagelab消息id，不为空
     * @param platform          厂商，取值范围（1:mi、2:huawei、3:meizu、4:oppo、5:vivo、7:honor、8:google）
     * @param platformMessageId 厂商消息id，可为空
     */
    public static void reportNotificationClicked(Context context, String messageId, byte platform, String platformMessageId)
```

示例代码如下

```
    // 上报厂商通知点击，messageId为“12345”，厂商为小米，厂商messageId为“MI-6476RHT25”
    MTPushPrivatesApi.reportNotificationClicked(context,“12345”,MTPushPrivatesApi.PLATFORM_XIAOMI,"MI-6476RHT25");
```

### <span id = "reportNotificationDeleted">reportNotificationDeleted</span>

> * 请先[init](#init)，否则调用无效
> * 不集成Engagelab的厂商包，但需要Engagelab统计通知删除率，请调用此接口

```
    /**
     * 上报厂商通道通知删除
     * 
     * 走http/https上报
     *
     * @param context           不为空
     * @param messageId         Engagelab消息id，不为空
     * @param platform          厂商，取值范围（1:mi、2:huawei、3:meizu、4:oppo、5:vivo、7:honor、8:google）
     * @param platformMessageId 厂商消息id，可为空
     */
    public static void reportNotificationDeleted(Context context, String messageId, byte platform, String platformMessageId)
```

示例代码如下

```
    // 上报厂商通知删除，messageId为“12345”，厂商为mi，厂商messageId为“MI-6476RHT25”
    MTPushPrivatesApi.reportNotificationDeleted(context,“12345”,MTPushPrivatesApi.PLATFORM_XIAOMI,"MI-6476RHT25");
```

### <span id = "reportNotificationOpened">reportNotificationOpened</span>

> * 请先[init](#init)，否则调用无效
> * 不集成Engagelab的厂商包，但需要Engagelab统计通知打开率，请调用此接口
> * 有些厂商（例如：huawei/oppo/vivo）没有通知到达和通知点击回调，配置通知点击跳转的activity后，可在跳转的activity内获取参数上报，建议所有厂商通知点击跳转的activity都配置
> * MTPush4.0.0以上版本不需要

```
    /**
     * 上报厂商通道通知打开
     * 
     * 走http/https上报
     *
     * @param context           不为空
     * @param messageId         Engagelab消息id，不为空
     * @param platform          厂商，取值范围（1:mi、2:huawei、3:meizu、4:oppo、5:vivo、7:honor、8:google）
     * @param platformMessageId 厂商消息id，可为空
     */
    public static void reportNotificationOpened(Context context, String messageId, byte platform, String platformMessageId)
```

示例代码如下

```
    Bundle bundle = intent.getExtras();
    String platformMessage = "";
    // huawei
    if (intent.getData() != null) {
        platformMessage = intent.getData().toString();
    }
    // 其他厂商
    if (TextUtils.isEmpty(platformMessage) && intent.getExtras() != null) {
        if (bundle.containsKey("JMessageExtra")) {
             platformMessage = bundle.getString("JMessageExtra");
        }else {
             platformMessage = bundle.getString("MTMessageExtra");
        }
    }
    if (TextUtils.isEmpty(platformMessage)) {
        return;
    }
    JSONObject messageJson = new JSONObject(platformMessage);
    tvMessage.setText(toLogString(messageJson));
    // 解析
    String messageId = messageJson.optString("msg_id");
    byte platform = (byte) messageJson.optInt("rom_type");
    String title = messageJson.optString("n_title");
    String content = messageJson.optString("n_content");
    // 上报通知点击activity打开，建议所有厂商跳转都加上，仅MTPush4.0.0以下版本需要
    MTPushPrivatesApi.reportNotificationOpened(this, messageId, platform, ""); 
```

### <span id = "uploadPlatformToken">uploadPlatformToken</span>

> * 请先[init](#init)，否则调用无效
> * 由于走tcp上传，需要长连接成功即[onConnectStatus](#onConnectStatus)回调结果为ture后调用此接口
> * 不集成Engagelab的厂商包，但需要Engagelab推送厂商消息

```
    /**
     * 上传厂商token
     * 
     * 走tcp上传
     *
     * @param context  不为空
     * @param platform 厂商，取值范围（1:mi、2:huawei、3:meizu、4:oppo、5:vivo、7:honor、8:google）
     * @param token    厂商返回的token，不为空
     * @param region    海外版小米和oppo需要设置region，国际版填:"GLOBAL",非海外版的填:"NULL"
     */
    public static void uploadPlatformToken(Context context, byte platform, String token, String region)
```

示例代码如下

```
    // 上报厂商token，厂商为mi，厂商token为“MI-6476s-afs-afs-afaR-HT25”
    MTPushPrivatesApi.uploadPlatformToken(context,MTPushPrivatesApi.PLATFORM_XIAOMI,"MI-6476s-afs-afs-afaR-HT25","NULL");
```

### code

| code               | int值 | 说明                                                         |
| ------------------ | ----- | ------------------------------------------------------------ |
| SUCCESS            | 0     | 成功                                                         |
| NULL_TAG_AND_ALIAS | 6001  | 无效的设置                                                   |
| TIMEOUT            | 6002  | 设置超时，建议重试，一般出现在网络不佳、初始化尚未完成时     |
| INVALID_ALIAS      | 6003  | alias字符串不合法，有效的别名、标签组成：字母（区分大小写）、数字、下划线、汉字、特殊字符( 2.1.6 支持)@!#$&*+=.\| |
| TOO_LONG_ALIAS     | 6004  | alias超长。最多 40 个字节，中文 UTF-8 是 3 个字节            |
| INVALID_TAGS       | 6005  | 某一个tag字符串不合法，有效的别名、标签组成：字母（区分大小写）、数字、下划线、汉字、特殊字符( 2.1.6 支持)@!#$&*+=.\| |
| TOO_LONG_TAG       | 6006  | 某一个tag超长。一个tag最多40个字节，中文UTF-8是3个字节       |
| TOO_MANY_TAGS      | 6007  | tags数量超出限制。最多1000个，这是一台设备的限制。一个应用全局的标签数量无限制。 |
| TOO_LONG_TAGS      | 6008  | tags操作单次长度超过5000                                     |
| UNKNOWN_ERROR      | 6009  | 未知错误                                                     |
| INVALID_JSON       | 6010  | 非法json                                                     |
| INVOKE_TOO_SOON    | 6012  | tag/alias操作频繁                                            |
| CONNECT_NOT_ENABLE | 6013  | CONNECT_NOT_ENABLE                                           |
| INVALID_MOBILE_NUMBER | 6023  | 无效手机号                                           |

### <span id = "onFragmentResume">onFragmentResume</span>

> * 请先[init](#init)，否则调用无效

```
    /**
     * @param context           不为空
     * @param fragmentName      Fragment页面完整类名（this.getClass().getCanonicalName()）
     */
    public static void onFragmentResume(Context context, String fragmentName)
```
### <span id = "onFragmentPause">onFragmentPause</span>

> * 请先[init](#init)，否则调用无效

```
    /**
     * @param context           不为空
     * @param fragmentName      Fragment页面完整类名（this.getClass().getCanonicalName()
     */
    public static void onFragmentPause(Context context, String fragmentName)
```
**使用说明：** 因为 Android 添加 Fragment 方式共有四种，而每种不同的添加方式，需要对Fragment的处理方式也有不一样。下面就针对 Fragment 的四种方式，指定在指定 Fragment 展示 in app 控制方式，分别进行说明。

| fragment使用方式               | 是否可以监听到Fragment生命周期                                                    | 极光动态指定展示页面接口调用方式                                |
| :----------------------------- | ---------------------------------------------------- | ---------------------------------------- |
| 方式一：add/show/hide   | 无法监听生命周期                                | Fragment 内的 onFragmentResume 与 onHiddenChaned 回调调用 
| 方式二：ViewPager   | 无法监听生命周期                                | Fragment 内的 setUserVisibleHint 回调调用 |
| 方式三：replace    | 可以监听生命周期                                | Fragment 内的生命周期回调 onResume与onPause 调用 |
| 方式四：attach/detach   | 可以监听生命周期                                | Fragment 内的生命周期回调 onResume 与 onPause 调用 |

- add/show/hide方式

      1）在 Fragment的onCreateView 回调函数中调用动态控制接口，并要求传入参数。
  
      @Override
      public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) {
          String classname = this.getClass().getCanonicalName();
          JPushInterface.onFragmentResumed(MyApplication.gContext, classname);
          return inflater.inflate(R.layout.black_fragment, container, false);
      }  

      2）在 Fragment 的 onHiddenChaned 回调接口中，调用动态控制接口，并按要求传入参数。
   
      @Override
      public void onHiddenChanged(boolean hidden) {
          String classname = this.getClass().getCanonicalName();
          if(!hidden){//context传application context
              JPushInterface.onFragmentResumed(MyApplication.gContext, classname);
          }else{//hide
              JPushInterface.onFragmentPaused(MyApplication.gContext, classname);  
          } 
          
          super.onHiddenChanged(hidden);
      }  

- ViewPager方式 

      1）在 Fragment 的 setUserVisibleHint 回调接口中，调用动态控制接口，并按要求传入参数。

      @Override
      public void setUserVisibleHint(boolean isVisibleToUser) {
          String classname = this.getClass().getCanonicalName();
          if(isVisibleToUser){
              //传application context
              JPushInterface.onFragmentResumed(MyApplication.gContext, classname);
          }else{//hide
              JPushInterface.onFragmentPause(MyApplication.gContext, classname);  
          } 
          
          super.setUserVisibleHint(isVisibleToUser);
      }    

- replace 方式或 attach/detach 方式

      在添加Fragment内的生命周期回调接口中，调用动态页面配置接口。

      @Override
      public void onResume() {//传application context
          String classname = this.getClass().getCanonicalName();
          JPushInterface.onFragmentResumed(MyApplication.gContext, classname);
          super.onResume();
      }
    
      @Override
      public void onPause() {
          String classname = this.getClass().getCanonicalName();
          JPushInterface.onFragmentPause(MyApplication.gContext, classname);  
          super.onPause();
      }


## MTCommonReceiver

> * 主要用于方法回调
> * 此类中所有方法回调均在主进程

### <span id = "onNotificationStatus">onNotificationStatus</span>

> * 每次启动sdk后都会回调当前通知开关状态
> * 后续通知开关有变化时才会回调

```
    /**
     * 应用通知开关状态回调
     *
     * @param context 不为空
     * @param enable  通知开关是否开，true为打开，false为关闭
     */
    @Override
    public void onNotificationStatus(Context context, boolean enable)
```

### <span id = "onConnectStatus">onConnectStatus</span>

```
    /**
     * 长连接是否连接成功
     *
     * 在初始化后会进行长连接，连接成功/失败均会回调此方法
     *
     * @param context 不为空
     * @param enable  长连接是否连接成功，true为成功；false为失败   
     */		
		public void onConnectStatus(Context context, boolean enable)
```

### <span id = "onNotificationArrived">onNotificationArrived</span>

> * Engagelab/小米/魅族通道会有此方法回调（google通道需要应用在前台才会有回调）
> * notificationMessage详情查看[NotificationMessage](#NotificationMessage)

```
    /**
     * 通知消息送达
     *
     * 推送的通知消息送达会回调此方法
     *
     * @param context 						不为空
     * @param notificationMessage 通知消息  
     */				
    public void onNotificationArrived(Context context, NotificationMessage notificationMessage)
```

### <span id = "onNotificationUnShow">onNotificationUnShow</span>

> * 后台下发前台不显示通知，且手机app在前台时回调该方法

```
    /**
     * 通知消息在前台不显示
     *
     * @param context             不为空
     * @param notificationMessage 通知消息
     */
    @Override
    public void onNotificationUnShow(Context context, NotificationMessage notificationMessage)
```

### <span id = "onNotificationClicked">onNotificationClicked</span>

> * Engagelab/小米/魅族通道会有此方法回调（google通道需要应用在前台才会有回调）
> * notificationMessage详情查看[NotificationMessage](#NotificationMessage)

```
    /**
     * 通知消息点击
     *
		 * 推送的通知消息点击会回调此方法
		 *
     * @param context 						不为空
     * @param notificationMessage 通知消息  
     */				
    public void onNotificationClicked(Context context, NotificationMessage notificationMessage)
```

### <span id = "onNotificationDeleted">onNotificationDeleted</span>

> * 只有Engagelab通道的通知消息删除才会触发
> * notificationMessage详情查看[NotificationMessage](#NotificationMessage)
> * 应用在死亡状态时无法回调

```
    /**
     * 通知消息删除
     * 
		 * 推送的通知消息删除会回调此方法
		 *
     * @param context 						不为空
     * @param notificationMessage 通知消息  
     */				
    public void onNotificationDeleted(Context context, NotificationMessage notificationMessage)
```

### <span id = "onCustomMessage">onCustomMessage</span>

> * 自定义消息不会展示在通知栏
> * 只有Engagelab通道的通知消息删除才会触发
> * customMessage详情查看[CustomMessage](#CustomMessage)

```
    /**
     * 自定义消息送达
     *
     * 自定义消息送达时会回调此方法
     *
     * @param context 			不为空
     * @param customMessage 自定义消息  
     */				
    public void onCustomMessage(Context context, CustomMessage customMessage)
```

### <span id = "onTagMessage">onTagMessage</span>

> * tagMessage详情查看[TagMessage](#TagMessage)

```
    /**
     * tag操作消息
     *
     * @param context    不为空
     * @param tagMessage 标签信息
     */		
    public void onTagMessage(Context context, TagMessage tagMessage)
```

### <span id = "onAliasMessage">onAliasMessage</span>

> * aliasMessage详情查看[AliasMessage](#AliasMessage)

```
    /**
     * alias操作消息
     *
     * @param context      ApplicationContext对象
     * @param aliasMessage 别名消息
     */
    public void onAliasMessage(Context context, AliasMessage aliasMessage)
```

### <span id = "onPlatformToken">onPlatformToken</span>

> * 厂商token消息回调

```
    /**
     * 厂商操作消息
     *
     * @param context         ApplicationContext对象
     * @param platformMessage 厂商token消息
     */
    public void onPlatformToken(Context context, PlatformTokenMessage platformMessage)
```
### <span id = "onInAppMessageShow"> onInAppMessageShow</span>

> * 应用内消息展示回调

```
    /**
     * 
     *
     * @param context         ApplicationContext对象
     * @param inAppMessage 应用内消息
     */
    public void onInAppMessageShow(Context context, InAppMessage inAppMessage)
```
### <span id = "onInAppMessageClick"> onInAppMessageClick</span>

> * 应用内消息点击回调

```
    /**
     * 
     *
     * @param context         ApplicationContext对象
     * @param inAppMessage 应用内消息
     */
    public void onInAppMessageClick(Context context, InAppMessage inAppMessage)
```
## NotificationChannel 配置

### 支持的版本

开始支持的版本：MTPush SDK v3.3.0

### 功能说明

Android8.0 以后通知都走 NotificationChannel 了。开发者可以自行定义 NotificationChannel，然后在 API 推送的时候可以指定 channelId 推送；
在 Android8.0 及以上的机型，通知会先查找对应 channelId 的 channel，通知的重要等级、声音、震动、呼吸灯由 channel 决定；
如果没有找到 channelId，或者处于静默时间内，则走默认的engagelab channel。

自定义 NotificationChannel 示例

```
    private void initChannel(){if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            if (nm != null){NotificationChannelGroup notificationChannelGroup = new NotificationChannelGroup("MyGroupId", "自定义通知组");
                nm.createNotificationChannelGroup(notificationChannelGroup);

                NotificationChannel notificationChannel = new NotificationChannel("MyChannelId", "自定义通知", NotificationManager.IMPORTANCE_HIGH);
                notificationChannel.setGroup("MyGroupId");
                notificationChannel.enableLights(true);
                notificationChannel.enableVibration(true);
                notificationChannel.setSound("android.resource:// 包名 /raw/ 铃声文件", null);    // 设置自定义铃声

                nm.createNotificationChannel(notificationChannel);
            }
        }
    }
```

## NotificationMessage

> * 通知消息

| 属性              | 类型     | 说明                                                         |
| ----------------- | -------- | ------------------------------------------------------------ |
| messageId         | String   | 必须，EngagelabmessageId，用于消息跟踪和统计，不能为空，为空不展示通知 |
| overrideMessageId | String   | EngagelaboverrideMessageId，用于消息跟踪和统计                    |
| platform          | byte     | 厂商类型，默认Engagelab，`MTPushPrivatesApi.PLATFORM_DEFAULT`：0<br />小米，`MTPushPrivatesApi.PLATFORM_XIAOMI`：1<br />华为，`MTPushPrivatesApi.PLATFORM_HUAWEI`：2<br />魅族，`MTPushPrivatesApi.PLATFORM_MEIZU`：3<br />oppo，`MTPushPrivatesApi.PLATFORM_OPPO`：4<br />vivo，`MTPushPrivatesApi.PLATFORM_VIVO`：5<br />honor，`MTPushPrivatesApi.PLATFORM_HONOR`：7<br />google，`MTPushPrivatesApi.PLATFORM_GOOGLE`：8 |
| platformMessageId | String   | 厂商messageId，用于厂商消息跟踪和统计                        |
| notificationId    | int      | 通知id，可调用[clearNotification](#clearNotification)取消通知 |
| smallIcon         | String   | 小图标，默认使用drawable/mtpush_notification_icon.png         |
| largeIcon         | String   | 大图标，一般位于通知右边                                     |
| title             | String   | 通知标题，为空时取应用名                                     |
| content           | String   | 必须，通知内容，不能为空，为空不展示通知                     |
| extras            | Bundle   | 额外字段，key/value格式均为String                            |
| builderId         | int      | 通知样式id，可调用[setNotificationLayout](#setNotificationLayout)设置通知样式，默认使用系统样式 |
| style             | int      | 通知风格，默认值为0<br />大文本风格NOTIFICATION_STYLE_BIG_TEXT：1<br />收件箱风格NOTIFICATION_STYLE_INBOX：2<br />大图片风格NOTIFICATION_STYLE_BIG_PICTURE：3 |
| bigText           | String   | 大文本，style为NOTIFICATION_STYLE_BIG_TEXT生效               |
| inbox             | String[] | 收件箱，style为NOTIFICATION_STYLE_INBOX生效                  |
| bigPicture        | String   | 大图片，style为NOTIFICATION_STYLE_BIG_PICTURE生效            |
| priority          | int      | 通知的紧急程度，默认值为0<br />低级，通知没有led灯、震动和铃声，Notification.PRIORITY_LOW：-1<br />普通，通知可以led灯、震动和铃声，Notification.PRIORITY_DEFAULT：0<br />高级，通知可以led灯、震动和铃声，还可以悬浮窗弹出，Notification.PRIORITY_HIGH：1 |
| defaults          | int      | 通知用于铃声、震动、led灯，默认值为Notification.DEFAULT_ALL：-1<br />铃声，Notification.DEFAULT_SOUND：1<br />震动，Notification.DEFAULT_VIBRATE：2<br />led灯，Notification.DEFAULT_LIGHTS：4<br />三种场景可自由组合，例如为7时，代表铃声、震动、led灯都有<br />Android8.0开始此属性跟随channel |
| category          | String   | 通知类型，用于通知栏的排序或者过滤，<br />种类繁多，类似Notification.CATEGORY_ALARM、Notification#CATEGORY_CALL |
| sound             | String   | 通知附带的铃声，需要提前在res/raw目录存在铃声文件<br />Android8.0开始，铃声跟随channel，如果通知使用的channel没有设置铃声，此通知不会对自定义铃声生效<br />建议提前将铃声设置在channel中，后续下发通知时的sound和channelId中的铃声保持一致，即可通知铃声效果保持一致性 |
| channelId         | String   | 从Android8.0开始需要，如果没有提前设置sdk会帮忙设置（仅限Engagelab通道和应用在前台时的google通道） |
| intentUri         | String   | 点击通知之后的跳转，目前仅支持activity，activity跳转使用`Intent.toURI()`转换得到 |
| badge             | int      | 此通知添加的角标数，属于累加逻辑，数值需要大于0，否则无效，建议填1<br />仅华为和小米生效<br />小米点击通知后，角标数会自动减1<br />华为点击通知后，角标数不会自动减1，建议调用[setNotificationBadge](#setNotificationBadge)设置 |

## CustomMessage

> * 自定义消息

| 属性              | 类型   | 说明                                                         |
| ----------------- | ------ | ------------------------------------------------------------ |
| messageId         | String | 必须，EngagelabmessageId，用于消息跟踪和统计，不能为空            |
| platform          | byte   | 厂商类型，默认Engagelab，`MTPushPrivatesApi.PLATFORM_DEFAULT`：0<br />小米，`MTPushPrivatesApi.PLATFORM_XIAOMI`：1<br />华为，`MTPushPrivatesApi.PLATFORM_HUAWEI`：2<br />魅族，`MTPushPrivatesApi.PLATFORM_MEIZU`：3<br />oppo，`MTPushPrivatesApi.PLATFORM_OPPO`：4<br />vivo，`MTPushPrivatesApi.PLATFORM_VIVO`：5<br />honor，`MTPushPrivatesApi.PLATFORM_HONOR`：7<br />google，`MTPushPrivatesApi.PLATFORM_GOOGLE`：8 |
| platformMessageId | String | 厂商messageId，用于厂商消息跟踪和统计                        |
| title             | String | 消息标题                                                     |
| content           | String | 消息标题                                                     |
| contentType       | String | 消息类型                                                     |
| extras            | Bundle | 额外字段，key/value格式均为String                            |

## TagMessage

> * 标签消息

| 属性          | 类型     | 说明                                                         |
| ------------- | -------- | ------------------------------------------------------------ |
| sequence      | int      | 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性 |
| code          | int      | 操作结果，详细请查看[code](#code)                            |
| tags          | String[] | 标签数组， 以下操作会返回 <br />[addTag](#addTag)<br />[deleteTag](#deleteTag)<br />[updateTag](#updateTag)<br />[queryAllTag](#queryAllTag) |
| queryTag      | String   | 标签，以下操作会返回<br />[queryTag](#queryTag)              |
| queryTagValid | boolean  | 标签状态，以下操作会返回<br />[queryTag](#queryTag)          |

## AliasMessage

> * 别名消息

| 属性     | 类型   | 说明                                                         |
| -------- | ------ | ------------------------------------------------------------ |
| sequence | int    | 用户自定义的操作序列号，同操作结果一起返回，用来标识一次操作的唯一性 |
| code     | int    | 操作结果，详细请查看[code](#code)                            |
| alias    | String | 别名，以下操作会返回<br />[setAlias](#setAlias)<br />[getAlias](#getAlias) |

## PlatformTokenMessage

> * 厂商token消息

| 属性     | 类型   | 说明                                                         |
| -------- | ------ | ------------------------------------------------------------ |
| platform | byte   | 厂商类型，默认Engagelab，`MTPushPrivatesApi.PLATFORM_DEFAULT`：0<br />小米，`MTPushPrivatesApi.PLATFORM_XIAOMI`：1<br />华为，`MTPushPrivatesApi.PLATFORM_HUAWEI`：2<br />魅族，`MTPushPrivatesApi.PLATFORM_MEIZU`：3<br />oppo，`MTPushPrivatesApi.PLATFORM_OPPO`：4<br />vivo，`MTPushPrivatesApi.PLATFORM_VIVO`：5<br />honor，`MTPushPrivatesApi.PLATFORM_HONOR`：7<br />google，`MTPushPrivatesApi.PLATFORM_GOOGLE`：8 |
| token    | String | 厂商返回的token|

## InAppMessage

> * 应用内消息

| 属性              | 类型     | 说明                                                         |
| ----------------- | -------- | ------------------------------------------------------------ |
| messageId         | String   | 必须，EngagelabmessageId，用于消息跟踪和统计，不能为空，为空不展示 |
| overrideMessageId | String   | EngagelaboverrideMessageId，用于消息跟踪和统计                    |
| target          | String[]     | 应用内消息展示目标页路径 |
| imageUrl | String   | 应用内消息图片地址                        |
| extras    | String      | 透传的额外信息 |
| content    | String      | 应用内消息具体内筒 |
| expired         | long   |过期时间         |
| delay         | long   | 延迟展示时间                                     |
| interval             | long   | 应用内消息间隔展示时间                                     |
| duration           | long   | 应用内消息展示时长                     |
| msgTime            | long   | SDK接收到应用内消息时间                            |

